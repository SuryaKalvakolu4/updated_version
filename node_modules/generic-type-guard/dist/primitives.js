"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.isNever = exports.isUnknown = exports.isAny = exports.isStringEnumeration = exports.isNumericalEnumeration = exports.isSet = exports.isObject = exports.isObjectLike = exports.isSetOf = exports.narrowArray = exports.narrowValue = exports.isArray = exports.isMissing = exports.isNullable = exports.isOptional = exports.isUndefined = exports.isNull = exports.isBoolean = exports.isSingletonStringUnion = exports.isSingletonString = exports.isString = exports.isSingletonNumberUnion = exports.isSingletonNumber = exports.isElementOf = exports.isNaN = exports.isInfinity = exports.isDouble = exports.isFloat = exports.isFiniteNumber = exports.isNumber = void 0;
var utils_1 = require("./utils");
var MINIMUM_ARRAY_INDEX = 0;
/**
 * Validate if a value is a javascript number.
 *
 * @public
 */
var isNumber = function (n) { return typeof n === 'number' && !isNaN(n); };
exports.isNumber = isNumber;
/**
 * Validate the value is a finite number.
 *
 * @public
 */
var isFiniteNumber = function (n) {
    return typeof n === 'number' && !isNaN(n) && isFinite(n);
};
exports.isFiniteNumber = isFiniteNumber;
/**
 * Validate the value is a number in the rawest sense.
 *
 * This check is exactly what the type system says on the tin. This value is a floating point value with all
 * the edge cases that entails.
 *
 * @public
 */
var isFloat = function (n) { return typeof n === 'number'; };
exports.isFloat = isFloat;
/**
 * Alias for isFloat.
 *
 * @see isFloat()
 * @public
 */
exports.isDouble = exports.isFloat;
/**
 * Validate the value is infinite.
 *
 * @public
 */
var isInfinity = function (n) {
    return typeof n === 'number' && !isNaN(n) && !isFinite(n);
};
exports.isInfinity = isInfinity;
/**
 * Validates a value is exactly the NaN constant value.
 *
 * @public
 */
var _isNaN = function (n) { return typeof n === 'number' && isNaN(n); };
exports.isNaN = _isNaN;
/**
 * Validates that a value is one of a set of values.
 *
 * @public
 */
exports.isElementOf = (function () {
    var ss = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        ss[_i] = arguments[_i];
    }
    return function (s) {
        return ss.indexOf(s) >= MINIMUM_ARRAY_INDEX;
    };
});
/**
 * Validate if a value is a specific javascript number.
 *
 * @public
 */
var isSingletonNumber = function (v) {
    return function (n) {
        return n === v;
    };
};
exports.isSingletonNumber = isSingletonNumber;
/**
 * Validate if a value is one of a set of specific numbers.
 *
 * @public
 */
exports.isSingletonNumberUnion = (function () {
    var ss = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        ss[_i] = arguments[_i];
    }
    return function (s) {
        return ss.indexOf(s) >= MINIMUM_ARRAY_INDEX;
    };
});
/**
 * Validate if a value is a string.
 *
 * @public
 */
var isString = function (s) { return typeof s === 'string'; };
exports.isString = isString;
/**
 * Validate if a value is a specific string.
 *
 * @public
 */
var isSingletonString = function (v) {
    return function (s) {
        return s === v;
    };
};
exports.isSingletonString = isSingletonString;
/**
 * Validate if a value is one of a set of specific strings.
 *
 * @public
 */
exports.isSingletonStringUnion = (function () {
    var ss = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        ss[_i] = arguments[_i];
    }
    return function (s) {
        return ss.indexOf(s) >= MINIMUM_ARRAY_INDEX;
    };
});
/**
 * Validate if a value is a boolean.
 *
 * @public
 */
var isBoolean = function (b) { return typeof b === 'boolean'; };
exports.isBoolean = isBoolean;
/**
 * Validate if a value is the constant null.
 *
 * @public
 */
var isNull = function (o) { return o === null; };
exports.isNull = isNull;
/**
 * Validate if a value is the constant undefined.
 *
 * @public
 */
var isUndefined = function (u) { return typeof u === 'undefined'; };
exports.isUndefined = isUndefined;
/**
 * Validate if a value is optionally a given type.
 *
 * @public
 */
var isOptional = function (tgt) {
    return function (o) {
        return typeof o === 'undefined' || tgt(o);
    };
};
exports.isOptional = isOptional;
/**
 * Validate if a value is a given type or null.
 *
 * @public
 */
var isNullable = function (tgt) {
    return function (o) {
        return o === null || tgt(o);
    };
};
exports.isNullable = isNullable;
/**
 * Validates if a value is a given type or null or undefined.
 *
 * @public
 */
var isMissing = function (tgt) {
    return function (o) {
        return o == null || tgt(o);
    };
};
exports.isMissing = isMissing;
/**
 * Validate if a value is an array of a specific type of value.
 *
 * @public
 */
var isArray = function (valueCheck) {
    return function (arr) {
        return Array.isArray(arr) && arr.reduce(function (acc, v) { return acc && valueCheck(v); }, true);
    };
};
exports.isArray = isArray;
/**
 * Narrow the type of a value.
 *
 * @public
 * @deprecated Use combine instead, this alias is poorly named.
 */
var narrowValue = function (ptt, ptu) { return (0, utils_1.combine)(ptt, ptu); };
exports.narrowValue = narrowValue;
/**
 * Narrow the type of elements inside an array.
 *
 * @public
 */
var narrowArray = function (pt) {
    return function (ts) {
        return ts.reduce(function (acc, b) { return acc && pt(b); }, true);
    };
};
exports.narrowArray = narrowArray;
/**
 * Validate if an object is a Set containing elements of a given type.
 *
 * @public
 */
var isSetOf = function (tg) {
    return function (o) {
        return o instanceof Set && Array.of.apply(Array, __spreadArray([], __read(o.values()), false)).reduce(function (acc, v) { return acc && tg(v); }, true);
    };
};
exports.isSetOf = isSetOf;
/**
 * Validate if a value is like an object.
 *
 * Specifically, this only checks typeof === "object" which includes
 * things that typescript has other primitives for like arrays.
 *
 * @public
 */
var isObjectLike = function (obj) { return obj != null && typeof obj === 'object'; };
exports.isObjectLike = isObjectLike;
/**
 * Validate if a value is an object.
 *
 * @public
 */
var isObject = function (obj) {
    return obj != null && typeof obj === 'object' && !(obj instanceof Array);
};
exports.isObject = isObject;
/**
 * Validates if a value is not null and not undefined.
 *
 * @public
 */
var isSet = function (obj) { return obj != null; };
exports.isSet = isSet;
/**
 * Validates if a value is a valid part of a numeric enumeration.
 *
 * @param e - The enumeration to check
 * @param flags - Whether this is a flag style enumeration
 *
 * @public
 */
var isNumericalEnumeration = function (e, flags) {
    if (flags === void 0) { flags = false; }
    var options = Object.values(e).filter(exports.isNumber);
    if (!flags) {
        return function (obj) { return options.includes(obj); };
    }
    else {
        return function (obj) {
            return typeof obj === 'number' &&
                obj !== 0 &&
                options.filter(function (v) { return (v & obj) === v; }).reduce(function (acc, v) { return acc | v; }, 0) === obj;
        };
    }
};
exports.isNumericalEnumeration = isNumericalEnumeration;
/**
 * Validates if a value is a valid part of a string enumeration.
 *
 * @param e - The enumeration to check
 *
 * @public
 */
var isStringEnumeration = function (e) {
    var options = Object.values(e);
    return function (obj) { return options.includes(obj); };
};
exports.isStringEnumeration = isStringEnumeration;
/**
 * Helper for asserting nothing at all.
 *
 * Note: this is very rarely useful. You probably want isSet. isAny
 * allows null and undefined through as well - it matches TypeScripts type
 * and simply returns a static true because anything is an any.
 *
 * You can use isSet to validate that a value is non-null then let TypeScript
 * widen it back to any in your interface.
 *
 * @public
 */
var isAny = function (_a) { return true; };
exports.isAny = isAny;
/**
 * Alias for isAny.
 *
 * @see isAny
 * @public
 */
exports.isUnknown = exports.isAny;
/**
 * Helper for exhaustiveness checking.
 *
 * @public
 */
var isNever = function (n) {
    throw Error("Unexpected value when expecting never: ".concat(n));
};
exports.isNever = isNever;
//# sourceMappingURL=primitives.js.map